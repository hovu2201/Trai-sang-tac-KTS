import JSZip from 'jszip';

import { RenovationResult } from '../types';
import {
  getDirectoryName,
  isFileSystemSupported,
  saveImageToLocalDirectory,
} from './fileSystemService';

const GALLERY_STORAGE_KEY = 'phong_nam_gallery';
const MAX_STORAGE_SIZE = 50 * 1024 * 1024; // 50MB limit - much more generous
const MAX_IMAGES = 200; // Maximum number of images to keep
const COMPRESSION_QUALITY = 0.7; // Compress images to 70% quality
const MAX_IMAGE_DIMENSION = 1920; // Max width/height for gallery images

export interface GalleryImage extends Omit<RenovationResult, 'imageUrl'> {
  imageId: string; // ID to reference image in IndexedDB
  thumbnailUrl?: string; // Optional small thumbnail for quick display
  createdAt: number;
  tags?: string[];
  favorite?: boolean;
  category?: string;
}

// Extended interface for use in components (includes loaded imageUrl)
export interface LoadedGalleryImage extends GalleryImage {
  imageUrl: string; // Loaded from IndexedDB as object URL
}

/**
 * Compress image to reduce localStorage usage
 */
const compressImage = async (imageUrl: string, quality: number = COMPRESSION_QUALITY): Promise<string> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = () => {
      // Calculate new dimensions (preserve aspect ratio)
      let width = img.width;
      let height = img.height;
      
      if (width > MAX_IMAGE_DIMENSION || height > MAX_IMAGE_DIMENSION) {
        if (width > height) {
          height = (height / width) * MAX_IMAGE_DIMENSION;
          width = MAX_IMAGE_DIMENSION;
        } else {
          width = (width / height) * MAX_IMAGE_DIMENSION;
          height = MAX_IMAGE_DIMENSION;
        }
      }
      
      // Create canvas and compress
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      
      if (!ctx) {
        reject(new Error('Could not get canvas context'));
        return;
      }
      
      ctx.drawImage(img, 0, 0, width, height);
      
      // Convert to base64 with compression
      const compressedUrl = canvas.toDataURL('image/jpeg', quality);
      
      console.log(`üóúÔ∏è Compressed image: ${(imageUrl.length / 1024).toFixed(0)}KB ‚Üí ${(compressedUrl.length / 1024).toFixed(0)}KB`);
      resolve(compressedUrl);
    };
    
    img.onerror = () => reject(new Error('Failed to load image for compression'));
    img.src = imageUrl;
  });
};

/**
 * Get all images from gallery (metadata only, without actual images)
 */
export const getGalleryMetadata = (): GalleryImage[] => {
  try {
    const stored = localStorage.getItem(GALLERY_STORAGE_KEY);
    if (!stored) return [];
    return JSON.parse(stored);
  } catch (error) {
    console.error('Error loading gallery metadata:', error);
    return [];
  }
};

/**
 * Get all images from gallery WITH loaded imageUrls from IndexedDB
 */
export const getGalleryImages = async (): Promise<LoadedGalleryImage[]> => {
  try {
    const metadata = getGalleryMetadata();
    
    // Load actual images from IndexedDB
    const loadedImages = await Promise.all(
      metadata.map(async (item) => {
        const imageUrl = await getImageFromIndexedDB(item.imageId);
        return {
          ...item,
          imageUrl: imageUrl || item.thumbnailUrl || '', // Fallback to thumbnail or empty
        } as LoadedGalleryImage;
      })
    );
    
    return loadedImages.filter(img => img.imageUrl); // Only return successfully loaded images
  } catch (error) {
    console.error('Error loading gallery images:', error);
    return [];
  }
};

/**
 * Save a new image to gallery using IndexedDB
 */
export const saveToGallery = async (result: RenovationResult): Promise<boolean> => {
  console.log('üîµ saveToGallery called with ID:', result.id);
  try {
    // 1. Save actual image to IndexedDB
    const imageId = `img_${result.id}`;
    await saveImageToIndexedDB(imageId, result.imageUrl);
    
    // 2. Create small thumbnail for quick display (optional)
    let thumbnailUrl: string | undefined;
    try {
      thumbnailUrl = await compressImage(result.imageUrl, 0.3); // 30% quality, very small
    } catch (err) {
      console.warn('Failed to create thumbnail:', err);
    }
    
    // 3. Get current metadata from localStorage
    const gallery = getGalleryMetadata();
    console.log('üîµ Current gallery size:', gallery.length);
    
    // Check if already exists - if yes, update it
    const existingIndex = gallery.findIndex(img => img.id === result.id);
    
    if (existingIndex !== -1) {
      // Update existing image (preserve favorite status and createdAt)
      const existingImage = gallery[existingIndex];
      gallery[existingIndex] = {
        ...result,
        imageUrl: compressedImageUrl, // Use compressed version
        createdAt: existingImage.createdAt, // Keep original timestamp
        favorite: existingImage.favorite,   // Keep favorite status
      };
      console.log('üîÑ Updated existing image in gallery at index:', existingIndex);
    } else {
      console.log('‚ûï Adding NEW image to gallery');
      // Add new image v·ªõi ·∫£nh ƒë√£ compress
      const newImage: GalleryImage = {
        ...result,
        imageUrl: compressedImageUrl, // Use compressed version
        createdAt: Date.now(),
        favorite: false,
      };

      // Try to save to local directory first (if configured) - save original quality
      if (isFileSystemSupported() && getDirectoryName()) {
        const filename = `phongnam_${newImage.id}_${Date.now()}.png`;
        const savedToLocal = await saveImageToLocalDirectory(result.imageUrl, filename); // Original quality
        if (savedToLocal) {
          console.log('üíæ Image saved to local directory (original quality)');
        }
      }

      // Add to beginning of array (newest first)
      gallery.unshift(newImage);
    }

    // Auto-cleanup: Keep only MAX_IMAGES, prioritize favorites
    let cleanedGallery = gallery;
    if (gallery.length > MAX_IMAGES) {
      const favorites = gallery.filter(img => img.favorite);
      const nonFavorites = gallery.filter(img => !img.favorite);
      const keepNonFavorites = nonFavorites.slice(0, Math.max(0, MAX_IMAGES - favorites.length));
      cleanedGallery = [...favorites, ...keepNonFavorites].sort((a, b) => b.createdAt - a.createdAt);
      console.warn(`Gallery limit reached. Keeping ${favorites.length} favorites and ${keepNonFavorites.length} recent images.`);
    }

    // Try to save
    const galleryString = JSON.stringify(cleanedGallery);
    
    try {
      localStorage.setItem(GALLERY_STORAGE_KEY, galleryString);
      console.log('‚úÖ Gallery saved successfully. Total images:', cleanedGallery.length);
      console.log('Storage size:', (galleryString.length / 1024).toFixed(2), 'KB');
      return true;
    } catch (storageError) {
      // Only handle actual quota errors silently - auto cleanup
      if (storageError instanceof DOMException && storageError.name === 'QuotaExceededError') {
        console.warn('‚ö†Ô∏è Storage quota exceeded, performing aggressive cleanup...');
        
        // Aggressive cleanup - keep only last 5 images + favorites
        const favorites = cleanedGallery.filter(img => img.favorite);
        const recent = cleanedGallery.filter(img => !img.favorite).slice(0, 5);
        const emergencyGallery = [...favorites, ...recent].sort((a, b) => b.createdAt - a.createdAt);
        
        try {
          localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(emergencyGallery));
          console.log(`‚úÖ Auto cleanup completed. Kept ${favorites.length} favorites + 5 recent images.`);
          
          // Show user notification
          setTimeout(() => {
            alert('‚ö†Ô∏è B·ªò NH·ªö TR√åNH DUY·ªÜT ƒê·∫¶Y!\n\n' +
                  'Th∆∞ vi·ªán ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông d·ªçn d·∫πp, ch·ªâ gi·ªØ l·∫°i 5 ·∫£nh g·∫ßn nh·∫•t.\n\n' +
                  'üí° Khuy·∫øn ngh·ªã:\n' +
                  '‚Ä¢ T·∫£i ·∫£nh v·ªÅ m√°y (ZIP) ƒë·ªÉ l∆∞u tr·ªØ l√¢u d√†i\n' +
                  '‚Ä¢ Ho·∫∑c ch·ªçn th∆∞ m·ª•c l∆∞u tr·ªØ c·ª•c b·ªô\n' +
                  '‚Ä¢ X√≥a ·∫£nh c≈© kh√¥ng c·∫ßn thi·∫øt');
          }, 500);
          
          return true;
        } catch (finalError) {
          console.error('‚ùå Failed after auto cleanup:', finalError);
          
          // Last resort - only favorites
          try {
            localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(favorites));
            console.log('üíæ Emergency: Saved only favorites');
            return true;
          } catch {
            return false;
          }
        }
      }
      throw storageError;
    }
    
  } catch (error) {
    if (error instanceof DOMException && error.name === 'QuotaExceededError') {
      // Last resort - emergency save with only new image
      console.error('‚ùå QuotaExceededError: Attempting emergency save...');
      
      const gallery = getGalleryImages();
      const favorites = gallery.filter(img => img.favorite).slice(0, 3); // Max 3 favorites
      
      try {
        // Compress again with lower quality
        let ultraCompressed = result.imageUrl;
        try {
          ultraCompressed = await compressImage(result.imageUrl, 0.5); // 50% quality
          console.log('üóúÔ∏è Ultra compression applied (50% quality)');
        } catch {}
        
        const emergencyGallery = [
          { ...result, imageUrl: ultraCompressed, createdAt: Date.now(), favorite: false },
          ...favorites.slice(0, 2) // Only 2 favorites max
        ];
        localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(emergencyGallery));
        console.log('üíæ Emergency cleanup: saved new image + max 2 favorites');
        
        setTimeout(() => {
          alert('‚ö†Ô∏è B·ªò NH·ªö C·ª∞C K·ª≤ H·∫†N CH·∫æ!\n\n' +
                'Ch·ªâ c√≥ th·ªÉ l∆∞u ·∫£nh m·ªõi + 2 ·∫£nh y√™u th√≠ch.\n\n' +
                'üö® B·∫ÆT BU·ªòC:\n' +
                '‚Ä¢ T·∫£i ·∫£nh v·ªÅ m√°y NGAY\n' +
                '‚Ä¢ Ho·∫∑c ch·ªçn th∆∞ m·ª•c l∆∞u tr·ªØ c·ª•c b·ªô\n' +
                '‚Ä¢ X√≥a b·ªõt ·∫£nh ƒë·ªÉ gi·∫£i ph√≥ng b·ªô nh·ªõ');
        }, 500);
        
        return true;
      } catch (finalError) {
        console.error('‚ùå Failed to save even after emergency cleanup:', finalError);
        alert('‚ùå KH√îNG TH·ªÇ L∆ØU ·∫¢NH!\n\nB·ªô nh·ªõ tr√¨nh duy·ªát ƒë·∫ßy.\nVui l√≤ng:\n1. X√≥a ·∫£nh c≈©\n2. Ho·∫∑c t·∫£i v·ªÅ m√°y\n3. Sau ƒë√≥ th·ª≠ l·∫°i');
        return false;
      }
    }
    console.error('Error saving to gallery:', error);
    return false;
  }
};

/**
 * Delete an image from gallery
 */
export const deleteFromGallery = (id: string): boolean => {
  try {
    const gallery = getGalleryImages();
    const filtered = gallery.filter(img => img.id !== id);
    localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(filtered));
    return true;
  } catch (error) {
    console.error('Error deleting from gallery:', error);
    return false;
  }
};

/**
 * Toggle favorite status
 */
export const toggleFavorite = (id: string): boolean => {
  try {
    const gallery = getGalleryImages();
    const image = gallery.find(img => img.id === id);
    if (image) {
      image.favorite = !image.favorite;
      localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(gallery));
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error toggling favorite:', error);
    return false;
  }
};

/**
 * Update image metadata
 */
export const updateImageMetadata = (
  id: string,
  updates: Partial<Pick<GalleryImage, 'tags' | 'category' | 'prompt' | 'description'>>
): boolean => {
  try {
    const gallery = getGalleryImages();
    const image = gallery.find(img => img.id === id);
    if (image) {
      Object.assign(image, updates);
      localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(gallery));
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error updating image metadata:', error);
    return false;
  }
};

/**
 * Export gallery as JSON
 */
export const exportGallery = (): string => {
  const gallery = getGalleryImages();
  return JSON.stringify(gallery, null, 2);
};

/**
 * Import gallery from JSON
 */
export const importGallery = (jsonString: string): boolean => {
  try {
    const imported = JSON.parse(jsonString) as GalleryImage[];
    if (!Array.isArray(imported)) {
      throw new Error('Invalid gallery format');
    }
    localStorage.setItem(GALLERY_STORAGE_KEY, JSON.stringify(imported));
    return true;
  } catch (error) {
    console.error('Error importing gallery:', error);
    return false;
  }
};

/**
 * Download all images as ZIP file
 */
export const downloadAllImagesAsZip = async (gallery: GalleryImage[]): Promise<void> => {
  try {
    if (gallery.length === 0) {
      alert('Th∆∞ vi·ªán tr·ªëng!');
      return;
    }

    const zip = new JSZip();
    const folder = zip.folder('PhongNam_Gallery');

    if (!folder) {
      throw new Error('Cannot create ZIP folder');
    }

    // Add each image to ZIP
    for (const img of gallery) {
      try {
        // Convert base64 to blob
        const base64Data = img.imageUrl.split(',')[1];
        const binaryData = atob(base64Data);
        const bytes = new Uint8Array(binaryData.length);
        for (let i = 0; i < binaryData.length; i++) {
          bytes[i] = binaryData.charCodeAt(i);
        }
        
        // Create filename with timestamp
        const date = new Date(img.createdAt);
        const dateStr = date.toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `${dateStr}_${img.id}.png`;
        
        folder.file(filename, bytes, { binary: true });
      } catch (imgError) {
        console.error(`Error adding image ${img.id} to ZIP:`, imgError);
      }
    }

    // Generate ZIP and download
    const content = await zip.generateAsync({ type: 'blob' });
    const url = URL.createObjectURL(content);
    const link = document.createElement('a');
    link.href = url;
    link.download = `PhongNam_Gallery_${Date.now()}.zip`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    console.log(`Downloaded ${gallery.length} images as ZIP`);
  } catch (error) {
    console.error('Error creating ZIP:', error);
    alert('L·ªói khi t·∫°o file ZIP: ' + (error as Error).message);
  }
};

/**
 * Get storage usage
 */
export const getStorageInfo = (): { used: number; max: number; percentage: number; count: number } => {
  try {
    const stored = localStorage.getItem(GALLERY_STORAGE_KEY);
    const used = stored ? stored.length * 2 : 0; // UTF-16 = 2 bytes per character
    const gallery = stored ? JSON.parse(stored) as GalleryImage[] : [];
    
    return {
      used,
      max: MAX_STORAGE_SIZE,
      percentage: Math.round((used / MAX_STORAGE_SIZE) * 100),
      count: gallery.length,
    };
  } catch (error) {
    console.error('Error getting storage info:', error);
    return { used: 0, max: MAX_STORAGE_SIZE, percentage: 0, count: 0 };
  }
};

/**
 * Clear entire gallery
 */
export const clearGallery = (): boolean => {
  try {
    localStorage.removeItem(GALLERY_STORAGE_KEY);
    return true;
  } catch (error) {
    console.error('Error clearing gallery:', error);
    return false;
  }
};
